<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CLASS MANUAL: CLASS overview (architecture, input/output, general principles)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CLASS MANUAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_chap3.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CLASS overview (architecture, input/output, general principles) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Author: Julien Lesgourgues</p>
<h1>Overall architecture of <code>class</code></h1>
<h2>Files and directories</h2>
<p>After downloading <code>CLASS</code>, one can see the following files in the root directory contains:</p>
<ul>
<li>some example of input files, the most important being <code>explanatory.ini</code>. a reference input file containing all possible flags, options and physical input parameters. While this documentation explains the structure and use of the code, <code>explanatory.ini</code> can be seen as the <em>physical</em> documentation of <code>CLASS</code>. The other input file are alternative parameter input files (ending with <code>.ini</code>) and precision input files (ending with <code>.pre</code>)</li>
<li>the <code>Makefile</code>, with which you can compile the code by typing <code>make clean; make;</code> this will create the executable <code>class</code> and some binary files in the directory <code>build/</code>. The <code>Makefile</code> contains other compilation options that you can view inside the file.</li>
<li><code>CPU.py</code> is a python script designed for plotting the <code>CLASS</code> output; for documentation type <code>python CPU.py --help</code></li>
<li><code>plot_CLASS_output.m</code> is the counterpart of <code>CPU.py</code> for MatLab</li>
<li>there are other input files for various applications: an example of a non-cold dark matter distribution functions (<code>psd_FD_single.dat</code>), and examples of evolution and selection functions for galaxy number count observables (<code>myevolution.dat, myselection.dat</code>).</li>
</ul>
<p>Other files are split between the following directories:</p>
<ul>
<li><code>source/</code> contains the C files for each <code>CLASS</code> module, i.e. each block containing some part of the physical equations and logic of the Boltzmann code.</li>
<li><code>tools/</code> contains purely numerical algorithms, applicable in any context: integrators, simple manipulation of arrays (derivation, integration, interpolation), Bessel function calculation, quadrature algorithms, parser, etc.</li>
<li><code>main/</code> contains the main module <code><a class="el" href="class_8c.html">class.c</a></code> with the main routine <code>class(...)</code>, to be used in interactive runs (but not necessarily when the code is interfaced with other ones).</li>
<li><code>test/</code> contains alternative main routines which can be used to run only some part of the code, to test its accuracy, to illustrate how it can be interfaced with other codes, etc.</li>
<li><code>include/</code> contains all the include files with a <code>.h</code> suffix.</li>
<li><code>output/</code> is where the output files will be written by default (this can be changed to another directory by adjusting the input parameter <code>root = &lt;...&gt;</code>)</li>
<li><code>python/</code> contains the python wrapper of <code>CLASS</code>, called classy (see <code>python/README</code>)</li>
<li><code>cpp/</code> contains the C++ wrapper of <code>CLASS</code>, called ClassEngine (see <code>cpp/README</code>)</li>
<li><code>doc/</code> contains the automatic documentation (manual and input files required to build it)</li>
<li><code>external_Pk/</code> contains examples of external codes that can be used to generate the primordial spectrum and be interfaced with <code>CLASS</code>, when one of the many options already built inside the code are not sufficient.</li>
<li><code>bbn/</code> contains interpolation tables produced by BBN codes, in order to predict e.g. <img class="formulaInl" alt="$ Y_\mathrm{He}(\omega_b, \Delta N_\mathrm{eff})$" src="form_0.png"/>.</li>
<li><code>hyrec/</code> contains the recombination code HyRec of Yacine Ali-Haimoud and Chris Hirata, that can be used as an alternative to the built-in Recfast (using the input parameter <code>recombination = &lt;...&gt;</code>).</li>
</ul>
<h2>The ten-module backbone</h2>
<h3>Ten tasks</h3>
<p>The purpose of <code>class</code> consists in computing some background quantities, thermodynamical quantities, perturbation transfer functions, and finally 2-point statistics (power spectra) for a given set of cosmological parameters. This task can be decomposed in few steps or modules:</p>
<ol type="1">
<li>set input parameter values.</li>
<li>compute the evolution of cosmological background quantities.</li>
<li>compute the evolution of thermodynamical quantities (ionization fractions, etc.)</li>
<li>compute the evolution of source functions <img class="formulaInl" alt="$S(k,\tau)$" src="form_1.png"/> (by integrating over all perturbations).</li>
<li>compute the primordial spectra.</li>
<li>eventually, compute non-linear corrections at small redshift/large wavenumber.</li>
<li>compute transfer functions in harmonic space <img class="formulaInl" alt="$\Delta_l(k)$" src="form_2.png"/> (unless one needs only Fourier spectra <img class="formulaInl" alt="$P(k)$" src="form_3.png"/>'s and no harmonic spectra <img class="formulaInl" alt="$C_l$" src="form_4.png"/>'s).</li>
<li>compute the observable power spectra <img class="formulaInl" alt="$C_l$" src="form_4.png"/>'s (by convolving the primordial spectra and the harmonic transfer functions) and/or <img class="formulaInl" alt="$P(k)$" src="form_3.png"/>'s (by multiplying the primordial spectra and the appropriate source functions <img class="formulaInl" alt="$S(k,\tau)$" src="form_1.png"/>).</li>
<li>eventually, compute the lensed CMB spectra (using second-order perturbation theory)</li>
<li>write results in files (when <code>CLASS</code> is used interactively. The python wrapper does not go through this step, after 1.-9. it just keeps the output stored internally).</li>
</ol>
<h3>Ten structures</h3>
<p>In <code>class</code>, each of these steps is associated with a structure:</p>
<ol type="1">
<li><code>struct precision</code> for input precision parameters (input physical parameters are dispatched among the other structures listed below)</li>
<li><code>struct background</code> for cosmological background,</li>
<li><code>struct thermo</code> for thermodynamics,</li>
<li><code>struct perturbs</code> for source functions,</li>
<li><code>struct primordial</code> for primordial spectra,</li>
<li><code>struct nonlinear</code> for nonlinear corrections,</li>
<li><code>struct transfers</code> for transfer functions,</li>
<li><code>struct spectra</code> for observable spectra,</li>
<li><code>struct lensing</code> for lensed CMB spectra,</li>
<li><code>struct output</code> for auxiliary variable describing the output format.</li>
</ol>
<p>A given structure contains "everything concerning one step that the
subsequent steps need to know" (for instance, <code>struct perturbs</code> contains everything about source functions that the transfer module needs to know). In particular, each structure contains one array of tabulated values (for <code>struct background</code>, background quantities as a function of time, for <code>struct thermo</code>, thermodynamical quantities as a function of redshift, for <code>struct perturbs</code>, sources <img class="formulaInl" alt="$S(k, \tau)$" src="form_5.png"/>, etc.). It also contains information about the size of this array and the value of the index of each physical quantity, so that the table can be easily read and interpolated. Finally, it contains any derived quantity that other modules might need to know. Hence, the communication from one module A to another module B consists in passing a pointer to the structure filled by A, and nothing else.</p>
<p>All "precision parameters" are grouped in the single structure <code>struct precision</code>. The code contains <em>no other arbitrary numerical coefficient</em>.</p>
<h3>Ten modules</h3>
<p>Each structure is defined and filled in one of the following modules (and precisely in the order below):</p>
<ol type="1">
<li><code><a class="el" href="input_8c.html">input.c</a></code></li>
<li><code><a class="el" href="background_8c.html">background.c</a></code></li>
<li><code><a class="el" href="thermodynamics_8c.html">thermodynamics.c</a></code></li>
<li><code><a class="el" href="perturbations_8c.html">perturbations.c</a></code></li>
<li><code><a class="el" href="primordial_8c.html">primordial.c</a></code></li>
<li><code><a class="el" href="nonlinear_8c.html">nonlinear.c</a></code></li>
<li><code><a class="el" href="transfer_8c.html">transfer.c</a></code></li>
<li><code><a class="el" href="spectra_8c.html">spectra.c</a></code></li>
<li><code><a class="el" href="lensing_8c.html">lensing.c</a></code></li>
<li><code><a class="el" href="output_8c.html">output.c</a></code></li>
</ol>
<p>Each of these modules contains at least three functions:</p>
<ul>
<li><code>module_init(...)</code></li>
<li><code>module_free(...)</code></li>
<li><code>module_something_at_somevalue</code></li>
</ul>
<p>where <em>module</em> is one of <code>input, background, thermodynamics, perturb, primordial, nonlinear, transfer, spectra, lensing, output</code>.</p>
<p>The first function allocates and fills each structure. This can be done provided that the previous structures in the hierarchy have been already allocated and filled. In summary, calling one of <code>module_init(...)</code> amounts in solving entirely one of the steps 1 to 10.</p>
<p>The second function deallocates the fields of each structure. This can be done optionally at the end of the code (or, when the code is embedded in a sampler, this <b>must</b> be done between each execution of <code>class</code>, and especially before calling <code>module_init(...)</code> again with different input parameters).</p>
<p>The third function is able to interpolate the pre-computed tables. For instance, <code><a class="el" href="background_8c.html#afeb0656453b92be39c60fb3fb1abd910">background_init()</a></code> fills a table of background quantities for discrete values of conformal time <img class="formulaInl" alt="$\tau$" src="form_6.png"/>, but <code>background_at_tau(tau, * values)</code> will return these values for any arbitrary <img class="formulaInl" alt="$\tau$" src="form_6.png"/>.</p>
<p>Note that functions of the type <code>module_something_at_somevalue</code> are the only ones which are called from another module, while functions of the type <code>module_init(...)</code> and <code>module_free(...)</code> are the only one called by the main executable. All other functions are for internal use in each module.</p>
<p>When writing a C code, the ordering of the functions in the *.c file is in principle arbitrary. However, for the sake of clarity, we always respected the following order in each <code>CLASS</code> module:</p>
<ol type="1">
<li>all functions that may be called by other modules, i.e. "external functions", usually named like <code>module_something_at_somevalue(...)</code></li>
<li>then, <code>module_init(...)</code></li>
<li>then, <code>module_free()</code></li>
<li>then, all functions used only internally by the module</li>
</ol>
<h2>The <code>main()</code> function(s)</h2>
<h3>The <code>main.c</code> file</h3>
<p>The main executable of <code>class</code> is the function <code>main()</code> located in the file <code>main/main.c</code>. This function consist only in the following lines (not including comments and error-management lines explained later): </p><pre class="fragment">main() {
 struct precision pr;

 struct background ba;

 struct thermo th;

 struct perturbs pt;

 struct primordial pm;

 struct nonlinear nl;

 struct transfers tr;

 struct spectra sp;

 struct lensing le;

 struct output op;


 input_init_from_arguments(argc, argv,&amp;pr,&amp;ba,&amp;th,&amp;pt,&amp;tr,&amp;pm,&amp;sp,&amp;nl,&amp;le,&amp;op,errmsg);

 background_init(&amp;pr,&amp;ba);

 thermodynamics_init(&amp;pr,&amp;ba,&amp;th);

 perturb_init(&amp;pr,&amp;ba,&amp;th,&amp;pt);

 primordial_init(&amp;pr,&amp;pt,&amp;pm);

 nonlinear_init(&amp;pr,&amp;ba,&amp;th,&amp;pt,&amp;pm,&amp;nl);

 transfer_init(&amp;pr,&amp;ba,&amp;th,&amp;pt,&amp;nl,&amp;tr);

 spectra_init(&amp;pr,&amp;ba,&amp;pt,&amp;pm,&amp;nl,&amp;tr,&amp;sp);

 lensing_init(&amp;pr,&amp;pt,&amp;sp,&amp;nl,&amp;le);

 output_init(&amp;ba,&amp;th,&amp;pt,&amp;pm,&amp;tr,&amp;sp,&amp;nl,&amp;le,&amp;op)


 /****** done ******/


 lensing_free(&amp;le);

 spectra_free(&amp;sp);

 transfer_free(&amp;tr);

 nonlinear_free(&amp;nl);

 primordial_free(&amp;pm);

 perturb_free(&amp;pt);

 thermodynamics_free(&amp;th);

 background_free(&amp;ba);
</pre><p>We can come back on the role of each argument. The arguments above are all pointers to the 10 structures of the code, excepted <code>argc, argv</code> which contains the input files passed by the user, and <code>errmsg</code> which contains the output error message of the input module (error management will be described below).</p>
<p><code>input_init_from_arguments</code> needs all structures, because it will set the precision parameters inside the <code>precision</code> structure, and the physical parameters in some fields of the respective other structures. For instance, an input parameter relevant for the primordial spectrum calculation (like the tilt <img class="formulaInl" alt="$n_s$" src="form_7.png"/>) will be stored in the <code>primordial</code> structure. Hence, in <code>input_init_from_arguments</code>, all structures can be seen as output arguments.</p>
<p>Other <code>module_init()</code> functions typically need all previous structures, which contain the result of the previous modules, plus its own structures, which contain some relevant input parameters before the function is called, as well as all the result form the module when the function has been executed. Hence all passed structures can be seen as input argument, excepted the last one which is both input and output. An example is <code>perturb_init(&amp;pr,&amp;ba,&amp;th,&amp;pt)</code>.</p>
<p>Each function <code>module_init()</code> does not need <b>all</b> previous structures, it happens that a module does not depend on a <b>all</b> previous one. For instance, the primordial module does not need information on the background and thermodynamics evolution in order to compute the primordial spectra, so the dependency is reduced: <code>primordial_init(&amp;pr,&amp;pt,&amp;pm)</code>.</p>
<p>Each function <code>module_init()</code> only deallocates arrays defined in the structure of their own module, so they need only their own structure as argument. (This is possible because all structures are self-contained, in the sense that when the structure contains an allocated array, it also contains the size of this array). The first and last module, <code>input</code> and <code>output</code>, have no <code>input_free()</code> or <code>output_free()</code> functions, because the structures <code>precision</code> and <code>output</code> do not contain arrays that would need to be de-allocated after the execution of the module.</p>
<h3>The <code>test_&lt;...&gt;.c</code> files</h3>
<p>For a given purpose, somebody could only be interested in the intermediate steps (only background quantities, only the thermodynamics, only the perturbations and sources, etc.) It is then straightforward to truncate the full hierarchy of modules 1, ... 10 at some arbitrary order. We provide several "reduced executables" achieving precisely this. They are located in <code>test/test_module_.c</code> (like, for instance, <code>test/test_perturbations.c</code>) and they can be complied using the Makefile, which contains the appropriate commands and definitions (for instance, you can type <code>make test_perturbations</code>).</p>
<p>The <code>test/</code> directory contains other useful example of alternative main functions, like for instance <code>test_loops.c</code> which shows how to call <code>CLASS</code> within a loop over different parameter values. There is also a version <code>test/test_loops_omp.c</code> using a double level of openMP parallelisation: one for running several <code>CLASS</code> instances in parallel, one for running each <code>CLASS</code> instance on several cores. The comments in these files are self-explanatory.</p>
<h1>Input/output</h1>
<h2>Input</h2>
<p>There are two types of input:</p>
<ul>
<li>"precision parameters" (controlling the precision of the output and the execution time),</li>
<li>"input parameters" (cosmological parameters, flags telling to the code what it should compute, ...)</li>
</ul>
<p>The code can be executed with a maximum of two input files, e.g. </p><pre class="fragment"> ./class explanatory.ini cl_permille.pre
</pre><p>The file with a <code>.ini</code> extension is the cosmological parameter input file, and the one with a <code>.pre</code> extension is the precision file. Both files are optional: all parameters are set to default values corresponding to the "most usual choices", and are eventually replaced by the parameters passed in the two input files. For instance, if one is happy with default accuracy settings, it is enough to run with </p><pre class="fragment"> ./class explanatory.ini
</pre><p>Input files do not necessarily contain a line for each parameter, since many of them can be left to default value. The example file <code>explanatory.ini</code> is very long and somewhat indigestible, since it contains all possible parameters, together with lengthy explanations. We recommend to keep this file unchanged for reference, and to copy it in e.g. <code>test.ini</code>. In the latter file, the user can erase all sections in which he/she is absolutely not interested (e.g., all the part on isocurvature modes, or on tensors, or on non-cold species, etc.). Another option is to create an input file from scratch, copying just the relevant lines from <code>explanatory.ini</code>. For the simplest applications, the user will just need a few lines for basic cosmological parameters, one line for the <code>output</code> entry (where one can specifying which power spectra must be computed), and one line for the <code>root</code> entry (specifying the prefix of all output files).</p>
<p>The syntax of the input files is explained at the beginning of <code>explanatory.ini</code>. Typically, lines in those files look like:</p>
<pre class="fragment">  parameter1 = value1

  free comments

  parameter2 = value2 # further comments

  # commented_parameter = commented_value
</pre><p>and parameters can be entered in arbitrary order. This is rather intuitive. The user should just be careful not to put an "=" sign not preceded by a "#" sign inside a comment: the code would then think that one is trying to pass some unidentified input parameter.</p>
<p>The syntax for the cosmological and precision parameters is the same. It is clearer to split these parameters in the two files <code>.ini</code> and <code>.pre</code>, but there is no strict rule about which parameter goes into which file: in principle, precision parameters could be passed in the <code>.ini</code>, and vice-versa. The only important thing is not to pass the same parameter twice: the code would then complain and not run.</p>
<p>The <code>CLASS</code> input files are also user-friendly in the sense that many different cosmological parameter bases can be used. This is made possible by the fact that the code does not only read parameters, it "interprets them" with the level of logic which has been coded in the <code><a class="el" href="input_8c.html">input.c</a></code> module. For instance, the Hubble parameter, the photon density, the baryon density and the ultra-relativistic neutrino density can be entered as: </p><pre class="fragment">  h = 0.7

  T_cmb = 2.726     # Kelvin units

  omega_b = 0.02

  N_eff = 3.04
</pre><p>(in arbitrary order), or as</p>
<pre class="fragment">  H0 = 70

  omega_g = 2.5e-5     # g is the label for photons

  Omega_b = 0.04

  omega_ur = 1.7e-5    # ur is the label for ultra-relativistic species
</pre><p>or any combination of the two. The code knows that for the photon density, one should pass one (but not more than one) parameter out of <code>T_cmb</code>, <code>omega_g</code>, <code>Omega_g</code> (where small omega's refer to <img class="formulaInl" alt="$\omega_i \equiv \Omega_i h^2$" src="form_9.png"/>). It searches for one of these values, and if needed, it converts it into one of the other two parameters, using also other input parameters. For instance, <code>omega_g</code> will be converted into <code>Omega_g</code> even if <img class="formulaInl" alt="$h$" src="form_10.png"/> is written later in the file than <code>omega_g</code>: the order makes no difference. Lots of alternatives have been defined. If the code finds that not enough parameters have been passed for making consistent deductions, it will complete the missing information with in-built default values. On the contrary, if it finds that there is too much information and no unique solution, it will complain and return an error.</p>
<p>In summary, the input syntax has been defined in such way that the user does not need to think too much, and can pass his preferred set of parameters in a nearly informal way.</p>
<p>Let us mention a two useful parameters defined at the end of <code>explanatory.ini</code>, that we recommend setting to <code>yes</code> in order to run the code in a safe way:</p>
<p><code>write parameters = [yes or no]</code> (<em>default</em>: <code>no</code>)</p>
<p>When set to yes, all input/precision parameters which have been read are written in a file <code>&lt;root&gt;parameters.ini</code>, to keep track all the details of this execution; this file can also be re-used as a new input file. Also, with this option, all parameters that have been passed and that the code did not read (because the syntax was wrong, or because the parameter was not relevant in the context of the run) are written in a file <code>&lt;root&gt;unused_parameters</code>. When you have doubts about your input or your results, you can check what is in there.</p>
<p><code>write warnings = [yes or no]</code> (<em>default</em>: <code>no</code>)</p>
<p>When set to yes, the parameters that have been passed and that the code did not read (because the syntax was wrong, or because the parameter was not relevant in the context of the run) are written in the standard output as <code>[Warning:]....</code></p>
<p>There is also a list of "verbose" parameters at the end of <code>explanatory.ini</code>. They can be used to control the level of information passed to the standard output (0 means silent; 1 means normal, e.g. information on age of the universe, etc.; 2 is useful for instance when you want to check on how many cores the run is parallelised; 3 and more are intended for debugging).</p>
<p><code>CLASS</code> comes with a list of precision parameter files ending by <code>.pre</code>. Honestly we have not been updating all these files recently, and we need to do a bit of cleaning there. However you can trust <code>cl_ref.pre</code>. We have derived this file by studying both the convergence of the CMB output with respect to all <code>CLASS</code> precision parameters, and the agreement with <code>CAMB</code>. We consider that this file generates good reference CMB spectra, accurate up to the hundredth of per cent level, as explained in the CLASS IV paper and re-checked since then. You can try it with e.g. </p><pre class="fragment">./class explanatory.ini cl_ref.pre
</pre><p>but the run will be extremely long. This is an occasion to run a many-core machine with a lot of RAM. It may work also on your laptop, but in half an hour or so.</p>
<p>If you want a reference matter power spectrum P(k), also accurate up to the hundredth of percent level, we recommend using the file <code>pk_ref.pre</code>, identical to <code>cl_ref.pre</code> excepted that the truncation of the neutrino hierarchy has been pushed to <code>l_max_ur=150</code>.</p>
<p>In order to increase moderately the precision to a tenth of percent, without prohibitive computing time, we recommend using <code>cl_permille.pre</code>.</p>
<h2>Output</h2>
<p>The input file may contain a line </p><pre class="fragment">  root = &lt;root&gt;
</pre><p>where <code>&lt;root&gt;</code> is a path of your choice, e.g. <code>output/test_</code>. Then all output files will start like this, e.g. <code>output/test_cl.dat</code>, <code>output/test_cl_lensed.dat</code>, etc. Of course the number of output files depends on your settings in the input file. There can be input files for CMB, LSS, background, thermodynamics, transfer functions, primordial spectra, etc. All this is documented in <code>explanatory.ini</code>.</p>
<p>If you do not pass explicitly a <code>root = &lt;root&gt;</code>, the code will name the output in its own way, by concatenating <code>output/</code>, the name of the input parameter file, and the first available integer number, e.g. </p><pre class="fragment"> output/explanatory03_cl.dat, etc.
</pre><h1>General principles</h1>
<h2>Error management</h2>
<p>Error management is based on the fact that all functions are defined as integers returning either <code>_SUCCESS_</code> or <code>_FAILURE_</code>. Before returning <code>_FAILURE_</code>, they write an error message in the structure of the module to which they belong. The calling function will read this message, append it to its own error message, and return a <code>_FAILURE_</code>; and so on and so forth, until the main routine is reached. This error management allows the user to see the whole nested structure of error messages when an error has been met. The structure associated to each module contains a field for writing error messages, called <code>structure_i.error_message</code>, where <code>structure_i</code> could be one of <code>background</code>, <code>thermo</code>, <code>perturbs</code>, etc. So, when a function from a module <img class="formulaInl" alt="$i$" src="form_11.png"/> is called within module <img class="formulaInl" alt="$j$" src="form_12.png"/> and returns an error, the goal is to write in <code>structure_j.error_message</code> a local error message, and to append to it the error message in <code>structure_i.error_message</code>. These steps are implemented in a macro <code>class_call()</code>, used for calling whatever function:</p>
<pre class="fragment">  class_call(module_i_function(...,structure_i),
            structure_i.error_message,
            structure_j.error_message);
</pre><p>So, the first argument of <code>call_call()</code> is the function we want to call; the second argument is the location of the error message returned by this function; and the third one is the location of the error message which should be returned to the higher level. Usually, in the bulk of the code, we use pointer to structures rather than structure themselves; then the syntax is </p><pre class="fragment">  class_call(module_i_function(...,pi),
         pi-&gt;error_message,
         pj-&gt;error_message);`
</pre><p>where in this generic example, <code>pi</code> and <code>pj</code> are assumed to be pointers towards the structures <code>structure_i</code> and <code>structure_j</code>.</p>
<p>The user will find in <code><a class="el" href="common_8h.html">include/common.h</a></code> a list of additional macros, all starting by <code>class_...()</code>, which are all based on this logic. For instance, the macro <code>class_test()</code> offers a generic way to return an error in a standard format if a condition is not fulfilled. A typical error message from <code>CLASS</code> looks like:</p>
<p><code>Error in module_j_function1</code></p>
<p><code>module_j_function1 (L:340) : error in module_i_function2(...)</code></p>
<p><code>module_i_function2 (L:275) : error in module_k_function3(...)</code></p>
<p><code>...</code></p>
<p><code>=&gt; module_x_functionN (L:735) : your choice of input parameter blabla=30 is not consistent with the constraint blabla&lt;1</code></p>
<p>where the <code>L</code>'s refer to line numbers in each file. These error messages are very informative, and are built almost entirely automatically by the macros. For instance, in the above example, it was only necessary to write inside the function <code>module_x_functionN()</code> a test like:</p>
<pre class="fragment">  class_test(blabla &gt;= 1,
              px-&gt;error_message,
           "your choice of input parameter blabla=%e
  is not consistent with the constraint blabla&lt;%e",
             blabla,blablamax);
</pre><p>All the rest was added step by step by the various <code>class_call()</code> macros.</p>
<h2>Dynamical allocation of indices</h2>
<p>On might be tempted to decide that in a given array, matrix or vector, a given quantity is associated with an explicit index value. However, when modifying the code, extra entries will be needed and will mess up the initial scheme; the user will need to study which index is associated to which quantity, and possibly make an error. All this can be avoided by using systematically a dynamical index allocation. This means that all indices remain under a symbolic form, and in each, run the code attributes automatically a value to each index. The user never needs to know this value.</p>
<p>Dynamical indexing is implemented in a very generic way in CLASS, the same rules apply everywhere. They are explained in these lecture slides:</p>
<p><code><a href="https://www.dropbox.com/sh/ma5muh76sggwk8k/AABl_DDUBEzAjjdywMjeTya2a?dl=0">https://www.dropbox.com/sh/ma5muh76sggwk8k/AABl_DDUBEzAjjdywMjeTya2a?dl=0</a></code></p>
<p>in the folder <code>CLASS_Lecture_slides/lecture5_index_and_error.pdf</code>.</p>
<h2>No hard coding</h2>
<p>Any feature or equation which could be true in one cosmology and not in another one should not be written explicitly in the code, and should not be taken as granted in several other places. Discretization and integration steps are usually defined automatically by the code for each cosmology, instead of being set to something which might be optimal for minimal models, and not sufficient for other ones. You will find many example of this in the code. As a consequence, in the list of precision parameter, you rarely find actual stepsize. You find rather parameters representing the ratio between a stepsize and a physical quantity computed for each cosmology.</p>
<h2>Modifying the code</h2>
<p>Implementing a new idea completly from scratch would be rather intimidating, even for the main developpers of <code>CLASS</code>. Fortunately, we never have to work from scratch. Usually we want to code a new species, a new observable, a new approximation scheme, etc. The trick is to think of another species, observable, approximation scheme, etc., looking as close as possible to the new one.</p>
<p>Then, playing with the <code>grep</code> command and the <code>search</code> command of your editor, search for all occurences of this nearest-as-possible other feature. This is usually easy thanks to our naming scheme. For each species, observable, approximation scheme, etc., we usually use the same sequence of few letters everywhere (fo instance, <code>fld</code> for the fluid usually representing Dark Energy). Grep for <code>fld</code> and you'll get all the lines related to the fluid. There is another way: we use everywhere some conditional jumps related to a given feature. For instance, the lines related to the fluid are always in between <code>if (pba-&gt;has_fld == _TRUE_) { ... }</code> and the lines related to the cosmic shear observables are always in between <code>if (ppt-&gt;has_lensing_potential == _TRUE_) { ... }</code>. Locating these flags and conditional jumps shows you all the parts related to a given feature/ingredient.</p>
<p>Once you have localised your nearest-as-possible other feature, you can copy/paste these lines and adapt them to the case of your new feature! You are then sure that you didn't miss any step, even the smallest technical steps (definition of indices, etc.)</p>
<h1>Units</h1>
<p>Internally, the code uses almost everywhere units of Mpc to some power, excepted in the inflation module, where many quantities are in natural units (wrt the true Planck mass). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Oct 22 2018 16:09:37 for CLASS MANUAL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
