# *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
# *  CLASS input parameter file  *
# *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*

# This example of input file, intended for CLASS beginners, lists all
# possibilities with detailed comments. You can use a more concise version, in
# which only the arguments in which you are interested would appear. Only lines
# containing an equal sign not preceded by a sharp sign "#" are considered by
# the code, any other line is considered as a comment.
#
# The normal syntax is:      parameter = value(s)
# where white spaces do not matter (they are removed automatically by the
# parser unless they are part of the parameter name).
# However,                   'parameter' = value(s)
# and                        "parameter" = value(s)
# are also accepted by the parser since v2.8.0
#
# Input files must have an extension ".ini".



# -------------------------
# ----> General parameters:
# -------------------------

# 1) List of output spectra requested:
#       - 'tCl' for temperature Cls,
#       - 'pCl' for polarization Cls,
#       - 'lCl' for CMB lensing potential Cls,
#       - 'nCl' (or 'dCl') for density number count Cls,
#       - 'sCl' for galaxy lensing potential Cls,
#       - 'mPk' for total matter power spectrum P(k) infered from gravitational
#         potential,
#       - 'dTk' (or 'mTk') for density transfer functions for each species,
#       - 'vTk' for velocity transfer function for each species
#       - 'sd' for spectral distortions
#    Warning: both lCl and sCl compute the C_ls of the lensing potential,
#    C_l^phi-phi. If you are used to other codes, you may want to deal instead
#    with the deflection Cls or the shear/convergence Cls. The relations
#    between them are trivial:
#        --> deflection d: Cl^dd = l(l+1) C_l^phiphi
#        --> convergence kappa and shear gamma: the share the same harmonic
#            power spectrum: Cl^gamma-gamma = 1/4 * [(l+2)!/(l-2)!] C_l^phi-phi
#    By defaut, the code will try to compute the following cross-correlation
#    Cls (if available): temperature-polarisation, temperature-CMB lensing,
#    polarization-CMB lensing, CMB lensing-density, and density-lensing. Other
#    cross-correlations are not computed because they would slow down the
#    code considerably.
#
#    Can be left blank if you do not want to evolve cosmological perturbations
#    at all. (default: set to blank, no perturbation calculation)
output = tCl,pCl,lCl,mPk
#output = tCl,pCl,lCl
#output = mPk,mTk
#output = Sd

# 1.a) If you included 'tCl' in the list, you can take into account only some
#      of the terms contributing to the temperature spectrum:
#         - intrinsic temperature corrected by Sachs-Wolfe ('tsw' or 'TSW'),
#         - early integrated Sachs-Wolfe ('eisw' or 'EISW'),
#         - late integrated Sachs-Wolfe ('lisw' or 'LISW'),
#         - Doppler ('dop' or 'Dop'),
#         - polarisation contribution ('pol' or 'Pol').
#      Put below the list of terms to be included (defaut: if this field is not
#      passed, all terms will be included)
#temperature_contributions = tsw, eisw, lisw, dop, pol

# 1.a.1) If one of 'eisw' or 'lisw' is turned off, the code will read
#        'early/late isw redshift', the split value of redshift z at which the
#        isw is considered as late or early (if this field is absent or left
#        blank, by default, 'early/late isw redshift' is set to 50)
#early_late_isw_redshift =

# 1.b) If you included 'nCl' (or 'dCl') in the list, you can take into account
#      only some of the terms contributing to the obsevable number count
#      fluctuation spectrum:
#          - matter density ('density'),
#          - redshift-space and Doppler distortions ('rsd'),
#          - lensing ('lensing'),
#          - or gravitational potential terms ('gr').
#      Put below the list of terms to be included (defaut: if this field is not
#      passed, only 'dens' will be included)
#number_count_contributions = density, rsd, lensing, gr

# 1.c) If you included 'dTk' (or 'mTk') in the list, the code will give you by
#      default the transfer function of the scale-invariant Bardeen potentials
#      (for whatever gauge you are using). If you need the transfer function of
#      additional metric fluctuations, specific to the gauge you are using, set
#      the following flag to 'yes' (default: set to 'no')
#extra_metric_transfer_functions = yes


# 2) If you want to consider perturbed recombination, enter a word
#    containing the letter 'y' or 'Y'. CLASS will then compute the
#    perturbation in the ionization fraction x_e and the baryon
#    temperature, as in 0707.2727. The initial conformal time will be
#    small, therefore you should use the default integrator ndf15
#    (i.e. do not set 'evolver' to 0, otherwise the code will be
#    slower).  (default: no, neglect perturbed recombination)
#perturbed_recombination = yes

# 3) List of modes:
#         - 's' for scalars,
#         - 'v' for vectors,
#         - 't' for tensors).
#      More than one letter allowed, can be attached or separated by arbitrary
#      characters; letters can be small or capital. (default: set to 's')
modes = s
#modes = s,t

# 3.a) List of initial conditions for scalars:
#           - 'ad' for adiabatic,
#           - 'bi' for baryon isocurvature,
#           - 'cdi' for CDM isocurvature,
#           - 'nid' for neutrino density isocurvature,
#           - 'niv' for neutrino velocity isocurvature.
#        More than one of these allowed, can be attached or separated by arbitrary
#        characters; letters can be small or capital. (default: set to 'ad')
ic = ad
#ic = ad&bi&nid

# 3.b) Which perturbations should be included in tensor calculations?
#           - write 'exact' to include photons, ultra-relativistic species 'ur'
#             and all non-cold dark matter species 'ncdm';
#           - write 'massless' to approximate 'ncdm' as extra relativistic species
#             (good approximation if ncdm is still relativistic at the time of
#             recombination);
#           - write 'photons' to include only photons
#        (default: set to 'massless')
tensor_method =


# 4) Gauge
# 4.a) Gauge in which calculations are performed:
#         - 'sync' or 'synchronous' or 'Synchronous' for synchronous,
#         - 'new' or 'newtonian' or 'Newtonian' for Newtonian/longitudinal gauge
#      (default: set to synchronous)
gauge = synchronous

# 4.b) Do you want to output the N-body gauge quantities as well?
#      If you included 'dTk' or 'vTk' in the list of outputs, you may transform
#      your transfer functions into the Nbody gauge by setting the following
#      flag to 'yes'. This will also include the transfer function for the
#      metric perturbations H_T' (exact) and gamma (approximate) in the Nbody gauge.
#      See e.g. 1505.04756, and equations (A.2) and (A.5) in 1811.00904
#      for more precise definitions. These calculations are more stable with
#      'gauge=synchronous' (default). To compute H_T' and gamma
#      without converting the output to the Nbody gauge,
#      please use the flag 'extra metric transfer functions' instead.
#      Can be set to anything starting with 'y' or 'n'.
#      (default: set to 'no')
#nbody_gauge_transfer_functions = yes

# 5) Hubble parameter : either 'H0' in km/s/Mpc or 'h' or '100*theta_s', where
#    the latter is the peak scale parameter defined exactly as 100(ds_dec/da_dec)
#    with a decoupling time given by maximum of visibility function (quite different
#    from theta_MC of CosmoMC and slightly different from theta_* of CAMB)
#    (default: 'h' set to 0.67810 such that 100*theta_s = 1.041783 like in Planck 2018)
h = 0.67810
#H0 = 67.810
#100*theta_s = 1.041783


# 6) Primordial Helium fraction 'YHe', e.g. 0.25; if set to 'BBN' or 'bbn',
#    will be inferred from Big Bang Nucleosynthesis (default: set to 'BBN')
YHe = BBN


# 7) 'recombination' algorithm set to 'RECFAST' or 'HyRec'. 'HyRec' points at HyRec 2020. Its compute time is negligible compared to other CLASS modules. 'RECFAST' points at RecFastCLASS, an enhanced version of RecFast 1.5 with better integration shceme and less discontinuities. Recfast is still slightly faster than HyRec but less accurate. HyRec is better for most purposes. RecFast can still be useful for studying some particular modifications of standard recombination. Both schemes use the CLASS ODE integrators. (Default: HyRec')
recombination = HyRec

# 7.a) If recombination algorithm is set to 'RECFAST'
#      the photo-ionization coefficients beta(T) for normal Recfast depend on Tmat
#      This is an approximation (see e.g. arxiv:1605.03928 page 10, arxiv:1503.04827 page 2, right column)
#      With 'recfast_photoion_dependence' the photo-ionization coefficient beta(T) is set to depend on
#          - 'Tmat' uses beta(Tmat) depending on matter temperature
#                   (like in original RECFAST and in CLASS v2.x)
#          - 'Trad' uses beta(Trad) depending on radiation temperature
#                   (while this option is theoretically more motivated, the option 'Tmat' leads to
#                    results which agree better with HyRec and CosmoRec. This is probably due to the
#                    fudge factor for the Peebles coefficient being optimized for a Tmat dependence)
#      (default: set to 'Tmat')
recfast_photoion_dependence =


# 8) Parametrization of reionization: 'reio_parametrization' must be one of
#       - 'reio_none' (no reionization),
#       - 'reio_camb' (like CAMB: one tanh() step for hydrogen reionization one
#         for second helium reionization),
#       - 'reio_bins_tanh' (binned history x_e(z) with tanh()  interpolation
#         between input values),
#       - 'reio_half_tanh' (like 'reio_camb' excepted that we match the
#         function xe(z) from recombination with only half a tanh(z-z_reio)),
#       - 'reio_many_tanh' (arbitrary number of tanh-like steps with specified
#         ending values, a scheme usually more useful than 'reio_bins_tanh'),
#       - 'reio_inter' (linear interpolation between discrete values of xe(z)).
#    (default: set to 'reio_camb')
reio_parametrization = reio_camb

# 8.a) If 'reio_parametrization' set to 'reio_camb' or 'reio_half_tanh':
#      enter one of 'z_reio' or 'tau_reio' (default: 'z_reio' set to 7.6711 to
#      get tau_reio of 0.054308), plus 'reionization_exponent',
#      'reionization_width', 'helium_fullreio_redshift',
#      'helium_fullreio_width'. (default: set to 1.5, 0.5, 3.5, 0.5)
z_reio = 7.6711
#tau_reio = 0.05430842
reionization_exponent = 1.5
reionization_width = 0.5
helium_fullreio_redshift = 3.5
helium_fullreio_width = 0.5

# 8.b) If 'reio_parametrization' set to 'reio_bins_tanh':
#      enter number of bins and list of z_i and xe_i defining the free electron
#      density at the center of each bin. Also enter a dimensionless paramater
#      regulating the sharpness of the tanh() steps, independently of the bin
#      width; recommended sharpness is 0.3, smaller values will make steps too
#      sharp, larger values will make the step very progressive but with
#      discontinuity of x_e(z) derivative around z_i values. (default: set to
#      0, blank, blank, 0.3)
binned_reio_num = 3
binned_reio_z = 8,12,16
binned_reio_xe = 0.8,0.2,0.1
binned_reio_step_sharpness = 0.3

# 8.c) If 'reio_parametrization' set to 'reio_many_tanh':
#      enter number of jumps, list of jump redhsifts z_i (central value of each
#      tanh()), list of free electron density x_i after each jump, and common
#      width of all jumps. If you want to end up with all hydrogen reionized
#      but neglecting helium reionization, the first value of x_i in the list
#      should be 1. For each x_i you can also pass the flags -1 or -2. They
#      mean:
#         - -1: after hydrogen + first helium recombination (so the code will
#               substitute a value bigger than one based on Y_He);
#         - -2: after hydrogen + second helium recombination (the code will
#               substitute an even bigger value based on Y_He).
#      You can get results close to reio_camb by setting these parameters to
#      the value showed below (and adapting the second many_tanh_z to the usual
#      z_reio). (default: not set)
many_tanh_num = 2
many_tanh_z = 3.5,11.3
many_tanh_xe = -2,-1
many_tanh_width = 0.5

# 8.d) If 'reio_parametrization' set to 'reio_inter': enter the number of
#      points, the list of redshifts z_i, and the list of free electron
#      fraction values x_i. The code will do linear interpolation between them.
#      The first z_i should always be 0. Like above, for each x_i, you can also
#      pass the flags -1 or -2. They mean: for -1, after the hydrogen and the
#      first helium recombination (so the code will substitute a value bigger
#      than one based on Y_He); for -2, after the hydrogen and the second
#      helium recombination (the code will substitute an even bigger value
#      based on Y_He). The last value of x_i should always be zero, the code
#      will substitute it with the value that one would get in absence of
#      reionization, as computed by the recombination code. (default: not set)
reio_inter_num = 8
reio_inter_z =   0,  3,  4,   8,   9,  10,  11, 12
reio_inter_xe = -2, -2, -1,  -1, 0.9, 0.5, 0.1,  0


# 9) State whether you want the code to compute the simplest analytic
#    approximation to the photon damping scale (it will be added to the
#    thermodynamics output, and its value at recombination will be stored and
#    displayed in the standard output) (default: 'compute damping scale' set to
#    'no')
compute_damping_scale =


# 10) State whether you want to include a variation of fudamental constants. Can be set to 'none' or to 'instantaneous'. Smoother evolutions could be included by modifying the function "background_varconst_of_z" in source/background.c.
varying_fundamental_constants = none

# 10.a) If 'varying_fundamental_constants' is set to 'instantaneous', select the redshift of the transition 'varying_transition_redshift' (default: 50). At lower redshift, the value will be the currently observed value, while at higher redshift you can specify how large the value should be by giving the ratio of the value at high redshift with respect to the currently observed one. Provide the relative value of the fine structure constant 'varying_alpha' (default: 1), and the relative value of the effective electron mass 'varying_me' (default: 1). The treatment corresponds to that of 1705.03925.
varying_transition_redshift =
varying_alpha = 1.
varying_me = 1.

# 10.b) If 'varying_fundamental_constants' is not set to 'none' and 'YHe' is set to 'BBN', specify by how much the 'YHe' prediction from 'BBN' should be affected by the different value of the fine structure constant. The default value is motivated by 2001.01787. (default: 1)
bbn_alpha_sensitivity = 1.


# -------------------------
# ----> Species parameters:
# -------------------------

# 1) Photon density: either 'T_cmb' in K or 'Omega_g' or 'omega_g' (default:
#    'T_cmb' set to 2.7255)
T_cmb = 2.7255
#Omega_g =
#omega_g =


# 2) Baryon density: either 'Omega_b' or 'omega_b' (default: 'omega_b' set to
#    0.02238280)
omega_b = 0.02238280
#Omega_b =


# 3) Ultra-relativistic species / massless neutrino density: either
# 'N_ur' or 'Omega_ur' or 'omega_ur' (default: 'N_ur' set to 3.044;
# see 2008.01074 and 2012.02726. This value is more accurate than the
# previous default value of 3.046) (note: instead of 'N_ur' you can
# pass equivalently 'N_eff', although this syntax is deprecated) (one
# more remark: if you have respectively 1,2,3 massive neutrinos, if
# you stick to the default value T_ncdm equal to 0.71611, designed to
# give m/omega of 93.14 eV, and if you want to use N_ur to get N_eff
# equal to 3.044 in the early universe, then you should pass here
# respectively 2.0308,1.0176,0.00441)
N_ur = 3.044
#Omega_ur =
#omega_ur =

# 3.a) To simulate ultra-relativistic species with non-standard properties, you
#      can pass 'ceff2_ur' and 'cvis2_ur' (effective squared
#      sound speed and viscosity parameter, like in the Generalised Dark Matter
#      formalism of W. Hu) (default: both set to 1/3)
#ceff2_ur =
#cvis2_ur =


# 4) Density of cdm (cold dark matter): 'Omega_cdm' or 'omega_cdm', or,
#    density of total non-relativistic matter: 'Omega_m' or 'omega_m'.
#    If you pass 'Omega_m' or 'omega_m', the code will automatically fill
#    up the density of Cold Dark Matter such that all non-relativistic species
#    (including non-cold DM) sum up to your input value of Omega_m
#    (default: 'omega_cdm' set to 0.1201075)
omega_cdm = 0.1201075
#Omega_cdm =
#Omega_m =
#omega_m =


# 5) ncdm sector (i.e. any non-cold dark matter relics, including massive
#    neutrinos, warm dark matter, etc.):
# 5.a) 'N_ncdm' is the number of distinct species (default: set to 0)
N_ncdm =

# 5.b) 'use_ncdm_psd_files' is the list of N_ncdm numbers:
#           - 0 means 'phase-space distribution (psd) passed analytically
#             inside the code, in the mnodule background.c, inside the function
#             background_ncdm_distribution()',
#           - 1 means 'psd passed as a file with at list two columns: first for
#             q, second for f_0(q)', where q is p/T_ncdm
#      (default: only zeros)
#use_ncdm_psd_files = 0

# 5.b.1) If some of the previous values are equal to one, 'ncdm_psd_filenames' is
#        the list of names of psd files (as many as number of ones in previous
#        entry)
ncdm_psd_filenames = psd_FD_single.dat

# 5.c) 'ncdm_psd_parameters' is an optional list of double parameters to
#      describe the analytic distribution function or to modify a p.s.d. passed
#      as a file. It is made available in the routine
#      background_ncdm_distribution.
#ncdm_psd_parameters = 0.3 ,0.5, 0.05
#ncdm_psd_parameters = Nactive, sin^2_12 ,s23 ,s13

# 5.d) 'Omega_ncdm' or 'omega_ncdm' or 'm_ncdm' in eV (default: all set to
#      zero); with only one of these inputs, CLASS computes the correct value
#      of the mass; if both (Omega_ncdm, m_ncdm) or (omega_ncdm, m_ncdm) are
#      passed, CLASS will renormalise the psd in order to fulfill both
#      conditions. Passing zero in the list of m_ncdm's or Omeg_ncdm's means
#      that for this component, this coefficient is not imposed, and its value
#      is inferred from the other one.
m_ncdm = 0.06
#m_ncdm = 0.04, 0.04, 0.04
#Omega_ncdm =
#omega_ncdm =

# 5.e) 'T_ncdm' is the ncdm temperature in units of photon temperature
#      (default: set to 0.71611, which is slightly larger than the
#      instantaneous decoupling value (4/11)^(1/3); indeed, this default value
#      is fudged to give a ratio m/omega equal to 93.14 eV for active
#      neutrinos, as predicted by precise studies of active neutrino
#      decoupling, see hep-ph/0506164)
T_ncdm =

# 5.f) 'ksi_ncdm' is the ncdm chemical potential in units of its own
#      temperature (default: set to 0)
ksi_ncdm =

# 5.g) 'deg_ncdm' is the degeneracy parameter multiplying the psd: 1 stands for
#      'one family', i.e. one particle + anti-particle (default: set to 1.0)
deg_ncdm =

# 5.h) 'ncdm_quadrature_strategy' is the method used for the momentum sampling of
#      the ncdm distribution function.
#         - 0 is the automatic method,
#         - 1 is Gauss-Laguerre quadrature,
#         - 2 is the trapezoidal rule on [0,Infinity] using the transformation q->1/t-1.
#         - 3 is the trapezoidal rule on [0,q_max] where q_max is the next input.
#      (default: set to 0)
ncdm_quadrature_strategy =

# 5.h.1) 'ncdm_maximum_q' is the maximum q relevant only for Quadrature strategy 3.
#        (default: set to 15)
ncdm_maximum_q =

# 5.h.2) Number of momentum bins. (default: 150)
ncdm_N_momentum_bins =


# 6) Curvature: 'Omega_k' (default: 'Omega_k' set to 0)
Omega_k = 0.


# Begin of ADDITIONAL SPECIES --> Add your species here

# 7.1) Decaying CDM into Dark Radiation
# 7.1.a) The current fractional density of dcdm+dr (decaying cold dark matter
#      and its relativistic decay radiation): 'Omega_dcdmdr' or 'omega_dcdmdr'
#      (default: 'Omega_dcdmdr' set to 0)
Omega_dcdmdr = 0.0
#omega_dcdmdr = 0.0

# 7.1.b) The rescaled initial value for dcdm density (see 1407.2418 for
#      definitions). If you specify 7.a.1, 7.a.2 will be found automtically by a
#      shooting method, and vice versa. (default: 'Omega_dcdmdr' set to 0,
#      hence so is 'Omega_ini_dcdm')
#Omega_ini_dcdm =
#omega_ini_dcdm =

# 7.1.c) Decay constant of dcdm in km/s/Mpc, same unit as H0 above.
Gamma_dcdm = 0.0
tau_dcdm = 0.0


# 7.2) Multi-interacting Dark Matter (idm), implemented by N. Becker,
#    D.C. Hooper, and N. Schoeneberg. Described in (2010.04074)

# 7.2.1) Global parameters for the (multi-)interacting Dark Matter component

# 7.2.1.a) Amount of interacting Dark Matter
# Can be passed as either f_idm (fraction) or Omega_idm (relative abundance) (default : 0)
#Omega_idm = 0.
f_idm = 0.

# 7.2.1.b) Mass of interacting Dark Matter particle in eV (default : 1e9)
m_idm = 1e9

# 7.2.2) Dark Matter interacting with Dark Radiation (idm_dr) and
#     interacting Dark Radiation (idr), implemented by
#     M. Archidiacono, S. Bohr, and D.C. Hooper, following the ETHOS
#     framework (1512.05344).  Can also take as input the parameters
#     of the models of 1507.04351 (with non-abelian dark matter, dark
#     gluons...) which can be seen as a sub-class of ETHOS. See
#     1907.01496 for more details on both cases.

# 7.2.2.a) Amount of interacting dark radiation (idr)
#        - Can be parameterised through the temperature ratio 'xi_idr' (= T_idr/T_cmb)
#        - Can be parameterised through the number of extra relativistic relics 'N_idr' (or indifferently 'N_dg')
#    In all cases the parameter is dimensionless.
# (default : 0)
xi_idr =
#N_idr =

# 7.2.2.b) Statistical factor to differentiate between fermionic (= 7/8) and bosonic (= 1) dark radiation (default 7/8)
stat_f_idr = 0.875

# 7.2.2.c) Strength of the coupling between DM and DR:
#
#     Can be passed as 'a_idm_dr' or 'a_dark' in ETHOS parameterisation, in units of 1/Mpc.
#      Then in ETHOS notations: Gamma_DR-DM = - omega_DM a_dark ((1+z)/10^7)^nindex_dark
#                        while: Gamma_DM-DR = - 4/3 (rho_DR/rho_DM) omega_DM  a_dark ((1+z)/10^7)^nindex_dark
#                                           = - 4/3 omega_DR a_dark (1+z) ((1+z)/10^7)^nindex_dark
#        or in CLASS notations: dmu_idm_dr  = - Gamma_DR-DM = omega_idm_dr a_idm_dr ((1+z)/10^7)^nindex_idm_dr
#
#     Can be passed as 'Gamma_0_nadm' in NADM parameterisation, in units of 1/Mpc.
#      Then in ETHOS notations: Gamma_DR-DM = - 3/4 Omega_DM/Omega_DR Gamma_0_nadm
#                        while: Gamma_DM-DR = - (1+z) Gamma_0_nadm
#      or in CLASS notations:   dmu_idm_dr  = - Gamma_DR-DM = 3/4 Omega_idm_dr/Omega_idr Gamma_0_nadm
#
#    (default : 0)
a_idm_dr = 0.
#Gamma_0_nadm =

# 7.2.2.d) Only if ETHOS parametrization : Power of the temperature dependence of the co-moving idr - idm_dr interaction rate
#    Can be passed indifferently as 'nindex_idm_dr' (or 'nindex_dark'), in units of 1/Mpc.
#    (default : 4, unless Gamma_0_nadm has been passed, then default changes to 0)
nindex_idm_dr =

# 7.2.2.e) Only if ETHOS parametrization : Nature of the interacting dark radiation: 'free_streaming' or 'fluid'
#    (default = 'free_streaming', unless Gamma_0_nadm has been passed, then default changes to 'fluid')
idr_nature =

# 7.2.2.f) Strength of the dark radiation self interactions coupling,
#    can be passed as 'b_idr' or 'b_dark', in units of 1/Mpc.
#    In ETHOS notations: Gamma_DR-DR = (b_dark/a_dark) (Omega_DR/Omega_DM) Gamma_DR-DM
#    In CLASS notations: dmu_idr = - Gamma_DR-DR = (b_idr/a_idm_dr) (Omega_idr/Omega_idm_dr) dmu_idm_dr
# (default : 0)
b_idr =

# 7.2.2.g) idr - idm_dr interaction angular coefficient: 'alpha_idm_dr' (or indifferently 'alpha_dark')
#    Should be 3/4 if vector boson mediator; 3/2 if scalar boson mediator.
#    In full generality this coefficient may depend on l = 2, 3, 4...
#    The user can pass here a list of values with an arbitrary size. The first coefficients will be adjusted
#    accordingly. After that, the last value will be repeated.
#    For instance, if users passes 3, 2, 1, the code will take alpha_2=3, alpha_3=2, and all others equal to 1.
#    (default = all set to 1.5)
alpha_idm_dr = 1.5

# 7.2.2.h) idr self-interaction angular coefficient: 'beta_idr' (or indifferently 'beta_dark')
#    In full generality this coefficient may depend on l = 2, 3, 4...
#    The user can pass here a list of values with an arbitrary size. The first coefficients will be adjusted
#    accordingly. After that, the last value will be repeated.
#    For instance, if users passes 3, 2, 1, the code will take beta_2=3, beta_3=2, and all others equal to 1.
#    (default = all set to 1.5)
beta_idr = 1.5

# -> Precision parameters for idm_dr and idr can be found in precisions.h, with the tag idm_dr

# 7.2.3) Interacting Dark Matter with Baryons
# Implemented by D.C. Hooper, N. Schoeneberg, and N. Becker
# following 1311.2937, 1509.00029, 1803.09734, 1802.06788

# 7.2.3.a) Coupling strength of Dark Matter and baryons (in cm^2) (default : 0)
cross_idm_b = 0.
# 7.2.3.b) Temperature dependence of the DM - baryon interactions (between -4 and 4) (default : 0)
n_index_idm_b = 0

# 7.2.4) Dark Matter interactions with photons
# Implementd by N. Becker following the formalism of Stadler&Boehm (1802.06589)

# 7.2.4.a) Interaction coefficient or coupling strength between DM and photons
#  Can be passed as either u_idm_g (dimensionless interaction strength) or cross_idm_g (cross section in cm^2) (default : 0)
u_idm_g = 0
#cross_idm_g = 0

# 7.2.4.b) Temperature dependence of the DM - photon interactions (default : 0)
n_index_idm_g = 0

# End of ADDITIONAL SPECIES


# 8) Dark energy contributions.
#    At least one out of three conditions must be satisfied:
#          - 'Omega_Lambda' unspecified.
#          - 'Omega_fld' unspecified.
#          - 'Omega_scf' set to a negative value. [Will be refered to as
#             unspecified in the following text.]
#      The code will then use the first unspecified component to satisfy the
#      closure equation (sum_i Omega_i) equals (1 + Omega_k)
#      (default: 'Omega_fld' and 'Omega_scf' set to 0 and 'Omega_Lambda'
#      inferred by code)
Omega_fld = 0
Omega_scf = 0
# Omega_Lambda = 0.7

# 8.a) If Omega fluid is different from 0

# 8.a.1) The flag 'use_ppf' is 'yes' by default, to use the PPF approximation
#        (see 0808.3125 [astro-ph]) allowing perturbations to cross the
#        phantom divide. Set to 'no' to enforce true fluid equations for
#        perturbations. When the PPF approximation is used, you can choose the
#        ratio 'c_gamma_over_c_fld' (eq. (16) in 0808.3125). The default is 0.4
#        as recommended by that reference, and implicitely assumed in other
#        codes. (default: 'use_ppf' to yes, 'c_gamma_over_c_fld' to 0.4)
use_ppf = yes
c_gamma_over_c_fld = 0.4

# 8.a.2) Choose your equation of state between different models,
#         - 'CLP' for p/rho = w0_fld + wa_fld (1-a/a0)
#           (Chevalier-Linder-Polarski),
#         - 'EDE' for early Dark Energy
#      (default:'fluid_equation_of_state' set to 'CLP')
fluid_equation_of_state = CLP

# 8.a.2.1) Equation of state of the fluid in 'CLP' case and squared sound speed
#          'cs2_fld' of the fluid (this is the sound speed defined in the frame
#          comoving with the fluid, i.e. obeying to the most sensible physical
#          definition). Generalizing w(a) to a more complicated expressions would
#          be easy, for that, have a look into source/background.c at the
#          function background_w_fld(). (default: 'w0_fld' set to -1, 'wa_fld' to
#          0, 'cs2_fls' to 1)
#w0_fld = -0.9
#wa_fld = 0.
#cs2_fld = 1

# 8.a.2.2) Equation of state of the fluid in 'EDE' case and squared sound speed
#          'cs2_fld' of the fluid (this is the sound speed defined in the frame
#          comoving with the fluid, i.e. obeying to the most sensible physical
#          definition). Generalizing w(a) to a more complicated expressions would
#          be easy, for that, have a look into source/background.c at the
#          function background_w_fld(). (default: 'w0_fld' set to -1, 'Omega_EDE'
#          to 0, 'cs2_fls' to 1)
#w0_fld = -0.9
#Omega_EDE = 0.
#cs2_fld = 1

# 8.b) If Omega scalar field is different from 0

# 8.b.1) Scalar field (scf) potential parameters and initial conditions
#        (scf_parameters = [scf_lambda, scf_alpha, scf_A, scf_B, phi,
#        phi_prime]). V = ((\phi-B)^\alpha + A)exp(-lambda*phi), see
#        http://arxiv.org/abs/astro-ph/9908085. If 'attractor_ic_scf' is set to
#        'no', the last two entries are assumed to be the initial values of phi
#        in units of the reduced planck mass m_Pl and the conformal time
#        derivative of phi in units of [m_Pl/Mpc]. (Note however that CLASS
#        determines the initial scale factor dynamically and the results might
#        not be as expected in some models.)
scf_parameters = 10.0, 0.0, 0.0, 0.0, 100.0, 0.0

# 8.b.2) Scalar field (scf) initial conditions from attractor solution (assuming
#        pure exponential potential). (default: yes)
attractor_ic_scf = yes

# 8.b.3) Scalar field (scf) shooting parameter: If Omega_scf is set (can only be negative),
#        the following index (0,1,2,...) in the list scf_parameters will be used for shooting:
#        (See also the section about shooting in input.c)
#        Basically parameter number scf_tuning_index will be adjusted until
#        the correct Omega_scf is found to suffice the budget equation
scf_tuning_index = 0


# 8.b.4) Scalar field (scf) shooting parameter. With this, you can overwrite some parameter
#        of 8.b.1) depending on the index defined in 8.b.3)
scf_shooting_parameter =

# -----------------------------------------
# ----> Exotic energy injection parameters:
# -----------------------------------------

# 1) DM Annihilation

# 1.a) In order to model energy injection from DM annihilation, specify a
#      parameter 'annihilation_efficiency' corresponding to
#      <sigma*v> / m_cdm expressed here in units of m^3/s/J. Alternatively,
#      you can specify the annihilation cross section in cm^3/s and the DM
#      mass in GeV. The code will then evaluate 'annihilation_efficiency'.
#     (default: all set to zero)
DM_annihilation_efficiency = 0.
#DM_annihilation_cross_section = 0.
#DM_annihilation_mass = 0.
#DM_annihilation_fraction = 0.

# 1.a.1) You can model simple variations of the above quantity as a function of
#        redhsift. If 'annihilation_variation' is non-zero, the function F(z)
#        defined as (<sigma*v> / m_cdm)(z) (see 1.a) will be a parabola in log-log scale
#        between 'annihilation_zmin' and 'annihilation_zmax', with a curvature
#        given by 'annihilation_variation' (must be negative), and with a maximum
#        in 'annihilation_zmax'; it will be constant outside this range. To
#        take DM halos into account, specify the parameters 'annihilation_f_halo',
#        the amplitude of the halo contribution, and 'annihilation_z_halo',
#        the characteristic redshift of halos (default: no variation,
#        'annihilation_variation' and 'annihilation_f_halo' set to zero).
DM_annihilation_variation = 0.
DM_annihilation_z = 1000
DM_annihilation_zmax = 2500
DM_annihilation_zmin = 30
DM_annihilation_f_halo= 0
DM_annihilation_z_halo= 8


# 2) DM electromagnetic decay

# 2.a) Specify the dimensionless parameter 'decay_fraction' which is
#      equal to the fraction of cdm with electromagnetic decay
#      products (decaying into dark radiation is handled by
#      Omega_dcdm).  Note: Until class 2.7, this parameter was called
#      'decay'. Its name and its meaning have slightly changed to
#      avoid confusion when working with model in which the lifetime
#      of the dcdm can be small (this is allowed providing that the
#      'decay_fraction' parameter is small as well).  (default: set to
#      0)
DM_decay_fraction = 0.

# 2.b) Specify the decay width of the particle 'decay_Gamma' in 1/s.
#      (default: set to 0)
DM_decay_Gamma = 0.


# 3) PBH evaporation. In this case, check that in 5), 'f_eff_type' and
# 'f_eff' have their default values 'on_the_spot' and 1, because CLASS
# will automatically take into account the time-dependent efficiency
# of energy injection from evaporating BH, taking the spectrum of
# evaporated particles into account.

# 3.a) Specify a dimensionless parameter 'PBH_evaporation_fraction' which is equal
#      to the fraction of evaporating PBH. (default set to 0)
PBH_evaporation_fraction = 0.

# 3.b) Specify the mass of the evaporating PBH in g. (default set to 0)
PBH_evaporation_mass = 0.


# 4) PBH matter accretion

# 4.a) Specify a dimensionless parameter 'PBH_accreting_fraction' which is equal
#      to the fraction of accreting PBH. (default set to 0)
PBH_accretion_fraction = 0.

# 4.b) Specify the mass of the accreting PBH in Msun. (default set to 0)
PBH_accretion_mass = 0.

# 4.c) Specify the 'PBH_accretion_recipe' between 'spherical_accretion'
# (computed according to Ali-Haimoud and Kamionkowski 1612.05644), or
# 'disk_accretion' (computed according to Poulin et al. 1707.04206).
# (default set to 'disk_accretion')
PBH_accretion_recipe = disk_accretion

# 4.c.1) If you choose 'spherical_accretion', you might want to specify the
#        relative velocity between PBH and baryons in km/s.
#        If negative, the linear result is chosen by the code.
#        (default set to -1., standard value is the linear result extrapolated to PBH.)
PBH_accretion_relative_velocities = -1.

# 4.c.2) If you choose 'disk_accretion', you might want to specify the
#        factor 'PBH_accretion_ADAF_delta' which, determines the heating
#        of the electrons in the disk, influencing the emissivity.
#        Can be set to 0.5 (aggressive scenario), 0.1 or 1.e-3 (conservative).
#        (default set to 1.e-3)
#        Furthermore you can also specify the the eigenvalue of the accretion
#        rate. It rescales the perfect Bondi case. (see e.g. Ali-Haimoud
#        & Kamionkowski 2016) (default set to 0.1, standard value in the ADAF
#        scenario.)
PBH_accretion_ADAF_delta = 1.e-3
PBH_accretion_eigenvalue = 0.1

# 5) Define the so-called injection efficiency f_eff, i.e. the factor
#    determining how much of the heating is deposited at all,
#    regardless of the form. There are two options to define this
#    function: 'on_the_spot' or 'from_file' (default: set to 'on_the_spot').
#
#    - with 'on_the_spot', the injected energy is transformed into deposited energy
#      at the same redshift with efficiency f_eff. In this case the
#      user can pass explicitely the value of f_eff. (default: f_eff=1)
#
#    - for 'from_file' the code reads a precomputed function in an external file
#      with a path set by the user (default set to "/external/heating/example_f_eff_file.dat")
f_eff_type = on_the_spot
#f_eff =
#f_eff_file = external/heating/example_f_eff_file.dat

# 6) Define the so-called deposition function chi, i.e the function which determines
#    the amount of energy effectively deposited into the different forms (heating,
#    ionization, Lyman alpha and low energy). There are several options
#        - by setting 'chi_type' to 'CK_2004', the approximation by Chen & Kamionkowski 2004 is employed.
#        - by setting 'chi_type' to 'PF_2005', the approximation by Padmanabhan & Finkbeiner 2005 is employed.
#        - by setting 'chi_type' to 'Galli_2013_file', the approximation by Galli et al. 2013 is employed.
#        - by setting 'chi_type' to 'Galli_2013_analytic', the approximation by Poulin is employed.
#          interpolating Galli et al. 2013 anyltically. Use this for consistency tests with
#          older versions of CLASS (2.x).
#        - by setting 'chi_type' to 'heat', the whole injected energy is going
#          to be deposited into heat.
#        - by setting 'chi_type' to 'from_x_file' or 'from_z_file', the user can
#          define own deposition functions with respect to the free electron
#          fraction x_e or to redshift, respectively.
#    (default set to 'CK_2004')
chi_type = CK_2004

# 6.a) If the option 'from_file' has been chosen, define the name of the file.
#      Two files 'example_chix_file.dat' and 'example_chiz_file.dat' are given
#      as example in external/heating. Note that 'example_chix_file.dat' has
#      been computed according to the approximations of Galli et al. 2013.
#      (default set to "/external/heating/example_f_eff_file.dat")
#chi_z_file = external/heating/example_chiz_file.dat;
#chi_x_file = external/heating/example_chix_file.dat;



# -------------------------------
# ----> Non-linear parameters:
# -------------------------------

# 1) If you want an estimate of the non-linear P(k) and Cls:
#    Enter 'halofit' or 'Halofit' or 'HALOFIT' for Halofit
#    Enter 'hmcode' or 'Hmcode' or 'HMcode' or 'HMCODE' for HMcode;
#    otherwise leave blank (default: blank, linear P(k) and Cls)
non_linear =

# 1.a) if you chose Halofit, and you have Omega0_fld != 0. (i.e. you
# set Omega_lambda=0.) & wa_fld != 0.,  then you might want to use the
# pk equal method of 0810.0190 and 1601.07230 by setting this flag to
# 'yes' (default: set to 'no')
pk_eq =

# 1.b)  if you chose HMcode:
#    In HMcode you can specify a baryonic feedback model (otherwise only DM is used).
#    Each model depends on two parameters: the minimum concentration "c_min" from the
#    Bullock et al. 2001 mass-concentration relation and the halo bloating parameter "eta_0"
#    introduced in Mead et al. 2015. In Mead et al. 2015 the parameters c_min and eta_0 are fitted
#    to the Cosmic Emulator dark matter only simulation (Heitman et al. 2014) and the
#    hydrodynamical OWLS simulations (Schaye et al. 2010, van Daalen et al. 2011).
#    You can choose between the 5 models of Mead et al. 2015, Table 4:
#      Model           (eta_0, c_min) Explanation
#    - 'emu_dmonly'    (0.603, 3.13)  fits the only dark matter Cosmic Emulator simulation (default)
#    - 'owls_dmonly'   (0.64, 3.43)   fits the OWLS simulation of dark matter only
#    - 'owls_ref'      (0.68, 3.91)   fits the OWLS simulation that includes gas cooling, heating,
#                                     star formation and evolution, chemical enrichment and supernovae feedback
#    - 'owls_agn'      (0.76, 2.32)   fits the OWLS simulation that includes AGN feedback
#    - 'owls_dblim'    (0.70, 3.01)   fits the OWLS simulation that has extra supernova energy in wind velocity
#    Set 'feedback model' to one of these names,
#    or leave blank and pass manually the value of either 'eta_0' or 'c_min'
#    (the other one will then be fixed according to equation (30) in Mead et al. 2015),
#    or pass manually the two values of 'eta_0' and 'c_min'
#    (default: 'feedback model' set to 'nl_emu_dmonly')
feedback model =
eta_0 =
c_min =

# ----------------------------
# ----> Primordial parameters:
# ----------------------------

# 1) Primordial spectrum type
#       - 'analytic_Pk' for an analytic smooth function with amplitude, tilt,
#         running, etc.; analytic spectra with feature can also be added as
#         a new type;
#       - 'inflation_V' for a numerical computation of the inflationary
#         primordial spectrum, through a full integration of the perturbation
#         equations, given a parametrization of the potential V(phi) in the
#         observable window, like in astro-ph/0703625;
#       - 'inflation_H' for the same, but given a parametrization of the
#         potential H(phi) in the observable window, like in
#         astro-ph/0710.1630;
#       - 'inflation_V_end' for the same, but given a parametrization of the
#         potential V(phi) in the whole region between the observable part and
#         the end of inflation;
#       - 'two scales' allows to specify two amplitudes instead of one
#         amplitude and one tilt, like in the isocurvature mode analysis of the
#         Planck inflation paper (works also for adiabatic mode only; see
#         details below, item 2.c);
#       - 'external_Pk' allows for the primordial spectrum to be computed
#         externally by some piece of code, or to be read from a table, see
#         2.d).
#    (default: set to 'analytic_Pk')
Pk_ini_type = analytic_Pk

# 1.a) Pivot scale in Mpc-1 (default: set to 0.05)
k_pivot = 0.05

# 1.b) For type 'analytic_Pk':
# 1.b.1) For scalar perturbations
#        curvature power spectrum value at pivot scale ('A_s' or
#        'ln10^{10}A_s') OR 'sigma8' (found by iterations using a shooting
#        method). (default: set 'A_s' to 2.100549e-09)
A_s = 2.100549e-09
#ln10^{10}A_s = 3.04478383
# sigma8 = 0.824398

# 1.b.1.1) Adiabatic perturbations:
#          tilt at the same scale 'n_s', and tilt running 'alpha_s'
#          (default: set 'n_s' to 0.9660499, 'alpha_s' to 0)
n_s = 0.9660499
alpha_s = 0.

# 1.b.1.2) Isocurvature/entropy perturbations:
#          for each mode xx ('xx' being one of 'bi', 'cdi', 'nid', 'niv',
#          corresponding to baryon, cdm, neutrino density and neutrino velocity
#          entropy perturbations), enter the entropy-to-curvature ratio f_xx,
#          tilt n_xx and running alpha_xx, all defined at the pivot scale; e.g.
#          f_cdi of 0.5 means S_cdi/R equal to one half and (S_cdi/R)^2 to 0.25
#          (default: set each 'f_xx' to 1, 'n_xx' to 1, 'alpha_xx' to 0)
f_bi = 1.
n_bi = 1.5
f_cdi=1.
f_nid=1.
n_nid=2.
alpha_nid= 0.01
# etc.

# 1.b.1.3) Cross-correlation between different adiabatic/entropy mode:
#          for each pair (xx, yy) where 'xx' and 'yy' are one of 'ad', 'bi',
#          'cdi', 'nid', 'niv', enter the correlation c_xx_yy (parameter between
#          -1 and 1, standing for cosDelta, the cosine of the cross-correlation
#          angle), the tilt n_xx_yy of the function cosDelta(k), and its running
#          alpha_xx_yy, all defined at the pivot scale. So, for a pair of fully
#          correlated (resp. anti-correlated) modes, one should set (c_xx_yy,
#          n_xx_yy, alpha_xx_yy) to (1,0,0) (resp. (-1,0,0) (default: set each
#          'c_xx_yy' to 0, 'n_xx_yy' to 0, 'alpha_xx_yy' to 0)
c_ad_bi = 0.5
#n_ad_bi = 0.1
c_ad_cdi = -1.
c_bi_nid = 1.
#n_bi_nid = -0.2
#alpha_bi_nid = 0.002
# etc.

# 1.b.2) For tensor perturbations (if any):
#        tensor-to-scalar power spectrum ratio, tilt,
#        running at the pivot scale; if 'n_t' and/or 'alpha_t' is set to 'scc'
#        or 'SCC' isntead of a numerical value, it will be inferred from the
#        self-consistency condition of single field slow-roll inflation: for
#        n_t, -r/8*(2-r/8-n_s); for alpha_t, r/8(r/8+n_s-1) (default: set 'r'
#        to 1, 'n_t' to 'scc', 'alpha_t' to 'scc')
r = 1.
n_t = scc
alpha_t = scc

# 1.c) For type 'inflation_V'
# 1.c.1) Type of potential: 'polynomial' for a Taylor expansion of the
#        potential around phi_pivot. Other shapes can easily be defined in
#        primordial module.
potential = polynomial

# 1.c.2) For 'inflation_V' and 'polynomial': enter either the coefficients
#        'V_0', 'V_1', 'V_2', 'V_3', 'V_4' of the Taylor expansion (in units of
#        Planck mass to appropriate power), or their ratios 'R_0', 'R_1',
#        'R_2', 'R_3', 'R_4' corresponding to (128pi/3)*V_0^3/V_1^2,
#        V_1^2/V_0^2, V_2/V_0, V_1*V_3/V_0, V_1^2*V_4/V_0^3, or the
#        potential-slow-roll parameters 'PSR_0', 'PSR_1', 'PSR_2', 'PSR_3',
#        'PSR_4', equal respectively to R_0, epsilon_V=R_1/(16pi),
#        eta_V=R_2/(8pi), ksi_V=R_3/(8pi)^2, omega_V=R_4/(8pi)^3 (default:
#        'V_0' set to 1.25e-13, 'V_1' to 1.12e-14, 'V_2' to 6.95e-14, 'V_3'
#        and 'V_4' to zero).
V_0=1.e-13
V_1=-1.e-14
V_2=7.e-14
V_3=
V_4=
#R_0=2.18e-9
#R_1=0.1
#R_2=0.01
#R_3=
#R_4=
#PSR_0 = 2.18e-9
#PSR_1 = 0.001989
#PSR_2 = 0.0003979
#PSR_3 =
#PSR_4 =

# 1.d) For 'inflation_H':
#      enter either the coefficients 'H_0', 'H_1', 'H_2', 'H_3', 'H_4' of the
#      Taylor expansion (in units of Planck mass to appropriate power), or the
#      Hubble-slow-roll parameters 'HSR_0', 'HSR_1', 'HSR_2', 'HSR_3', 'HSR_4'
H_0=1.e-13
H_1=-1.e-14
H_2=7.e-14
H_3=
H_4=
#HSR_0 = 2.18e-9
#HSR_1 = 0.001989
#HSR_2 = 0.0003979
#HSR_3 =
#HSR_4 =

# 1.e) For type 'inflation_V_end':
# 1.e.1) Value of the field at the minimum of the potential after inflation, or
#        at a value in which you want to impose the end of inflation, in
#        hybrid-like models. By convention, the code expects inflation to take
#        place for values smaller than this value, with phi increasing with
#        time (using a reflection symmetry, it is always possible to be in that
#        case) (default: 'phi_end' set to 0)
phi_end =

# 1.e.2) Shape of the potential. Refers to functions pre-coded in the primordail
#        module, so far 'polynomial' and 'higgs_inflation'. (default:
#        'full_potential' set to 0)
full_potential = polynomial

# 1.e.3) Parameters of the potential. The meaning of each parameter is
#        explained in the function primrodial_inflation_potential() in
#        source/primordial.c
Vparam0 =
Vparam1 =
Vparam2 =
Vparam3 =
Vparam4 =

# 1.e.4) How much the scale factor a or the product (aH) increases between
#        Hubble crossing for the pivot scale (during inflation) and the end of
#        inflation. You can pass either: 'N_star' (standing for
#        log(a_end/a_pivot)) set to a number; or 'ln_aH_ratio' (standing for
#        log(aH_end/aH_pivot)) set to a number; (default: 'N_star' set to 60)
#ln_aH_ratio = 50
#N_star = 55

# 1.e.5) Should the inflation module do its nomral job of numerical integration
#        ('numerical') or use analytical slow-roll formulas to infer the
#        primordial spectrum from the potential ('analytical')? (default:
#        'inflation_behavior' set to 'numerical')
#inflation_behavior = numerical

# 1.f) For type 'two_scales' (currently this option works only for scalar modes,
#      and either for pure adiabatic modes or adiabatic + one type of
#      isocurvature):
# 1.f.1) Two wavenumbers 'k1' and 'k2' in 1/Mpc, at which primordial amplitude
#        parameters will be given. The value of 'k_pivot' will not be used in
#        input but quantities at k_pivot will still be calculated and stored in
#        the primordial structure (no default value: compulsory input if
#        'P_k_ini type' has been set to 'two_scales')
k1=0.002
k2=0.1

# 1.f.2) Two amplitudes 'P_{RR}^1', 'P_{RR}^2' for the adiabatic primordial
#        spectrum (no default value: compulsory input if 'P_k_ini type' has been
#        set to 'two_scales')
P_{RR}^1 = 2.3e-9
P_{RR}^2 = 2.3e-9

# 1.f.3) If one isocurvature mode has been turned on ('ic' set e.g. to 'ad,cdi'
#        or 'ad,nid', etc.), enter values of the isocurvature amplitude
#        'P_{II}^1', 'P_{II}^2', and cross-correlation amplitude 'P_{RI}^1',
#        '|P_{RI}^2|' (see Planck paper on inflation for details on
#        definitions)
P_{II}^1 = 1.e-11
P_{II}^2 = 1.e-11
P_{RI}^1 = -1.e-13
|P_{RI}^2| = 1.e-13

# 1.f.4) Set 'special iso' to 'axion' or 'curvaton' for two particular cases:
#        'axion' means uncorrelated, n_ad equal to n_iso, 'curvaton' means fully
#        anti-correlated with f_iso<0 (in the conventions of the Planck
#        inflation paper this would be called fully correlated), n_iso equal
#        to one; in these two cases, the last three of the four paramneters in
#        2.c.3 will be over-written give the input for 'P_{II}^1' (defaut:
#        'special_iso' left blanck, code assumes general case described by four
#        parameters of 2.c.3)
special_iso =

# 1.g) For type 'external_Pk' (see external documentation external_Pk/README.md
#      for more details):
# 1.g.1) Command generating the table. If the table is already generated, just
#        write "cat <table_file>". The table should have two columns (k, pk) if
#        tensors are not requested, or three columns (k, pks, pkt) if they are.
#command = python external/external_Pk/generate_Pk_example.py
#command = python external/external_Pk/generate_Pk_example_w_tensors.py
command = cat external/external_Pk/Pk_example.dat
#command = cat external/external_Pk/Pk_example_w_tensors.dat

# 1.g.2) If the table is not pregenerated, parameters to be passed to the
#        command, in the right order, starting from "custom1" and up to
#        "custom10". They must be real numbers.
custom1 = 0.05     # In the example command: k_pivot
custom2 = 2.215e-9 # In the example command: A_s
custom3 = 0.9624   # In the example command: n_s
custom4 = 2e-10    # In the example (with tensors) command: A_t
custom5 = -0.1     # In the example (with tensors) command: n_t
#custom6 = 0
#custom7 = 0
#custom8 = 0
#custom9 = 0
#custom10 = 0



# -------------------------
# ----> Spectra parameters:
# -------------------------

# 1) Maximum l for CLs:
#        - 'l_max_scalars' for CMB scalars (temperature, polarization, cmb
#          lensing potential),
#        - 'l_max_vectors' for CMB vectors
#        - 'l_max_tensors' for CMB tensors (temperature, polarization)
#        - 'l_max_lss'     for Large Scale Structure Cls (density, galaxy
#          lensing potential)
#    Reducing 'l_max_lss' with respect to l_max_scalars reduces the execution
#    time significantly (default: set 'l_max_scalars' to 2500, 'l_max_vectors'
#    to 500, 'l_max_tensors' to 500, 'l_max_lss' to 300)
l_max_scalars = 2500
#l_max_vectors = 500
l_max_tensors = 500
#l_max_lss = 300


# 2) Parameters for the the matter density number count (option 'nCl'
#    (or 'dCl')) or galaxy lensing potential (option 'sCl') Cls:
# 2.a) Enter here a description of the selection functions W(z) of each redshift
#      bin; selection can be set to 'gaussian', 'tophat' or 'dirac', then pass a
#      list of N mean redshifts in growing order separated by comas, 1 or N
#      widths separated by comas, 1 or N bias separated by a comma, and 1 or N
#      magnification bias separated by a comma. The width stands for one
#      standard deviation of the gaussian (in z space), or for the half-width of
#      the top-hat. Finally, non_diagonal sets the number of cross-correlation
#      spectra that you want to calculate: 0 means only auto-correlation, 1
#      means only adjacent bins, and number of bins minus one means all
#      correlations (default: set to 'gaussian',1,0.1,1.,0.,0)
#
#      NOTE: For good performances, the code uses the Limber approximation for
#            nCl. If you want high precision even with thin selection functions,
#            increase the default value of the precision parameters
#            l_switch_limber_for_nc_local_over_z and
#            l_switch_limber_for_nc_los_over_z; for instance, add them to the
#            input file with values 10000 and 2000, instead of the default 100
#            and 30.
selection=gaussian
selection_mean = 0.98,0.99,1.0,1.1,1.2
selection_width = 0.1
selection_bias =
selection_magnification_bias =
non_diagonal=4

# 2.b) It is possible to multiply the window function W(z) by a selection
#      function 'dNdz' (number of objects per redshift interval). Type the name
#      of the file containing the redshift in the first column and the number of
#      objects in the second column (do not call it 'analytic*'). Set to
#      'analytic' to use instead the analytic expression from arXiv:1004.4640
#      (this function can be tuned in the module transfer.c, in the subroutine
#      transfer_dNdz_analytic). Leave blank to use a uniform distribution
#      (default).
dNdz_selection =

# 2.c) It is possible to consider source number counts evolution. Type the name
#      of the file containing the redshift on the first column and the number
#      of objects on the second column (do not call it 'analytic*'). Set to
#      'analytic' to use instead the analytic expression from Eq. 48 of
#      arXiv:1105.5292. Leave blank to use constant comoving number densities
#      (default).
dNdz_evolution =


# 3) Power spectrum P(k)
# 3.a) Maximum k in P(k), 'P_k_max_h/Mpc' in units of h/Mpc or 'P_k_max_1/Mpc'
#      inunits of 1/Mpc. If scalar Cls are also requested, a minimum value is
#      automatically imposed (the same as in scalar Cls computation) (default:
#      set to 1 1/Mpc)
P_k_max_h/Mpc = 1.
#P_k_max_1/Mpc = 0.7

# 3.a.1) If you want to use a different value for k_max in the primordial and
#        perturbations structures, specify
#        'primordial_P_k_max_h/Mpc' in units of h/Mpc or
#        'primordial_P_k_max_1/Mpc' in units of 1/Mpc
#        to define the maximum value of k for primordial power spectrum. By doing
#        so, 'P_k_max_h/Mpc' will only apply to perturbations. If unspecified,
#        'primordial_P_k_max_h/Mpc' is assumed to be the same as 'P_k_max_h/Mpc'.
#primordial_P_k_max_h/Mpc =
#primordial_P_k_max_1/Mpc =

# 3.b) Value(s) 'z_pk' of redshift(s) for P(k,z) output file(s); can be ordered
#      arbitrarily, but must be separated by comas (default: set 'z_pk' to 0)
z_pk = 0
#z_pk = 0., 1.2, 3.5

# 3.c) If the code is interfaced with routines that need to interpolate P(k,z) at
#      various values of (k,z), enter 'z_max_pk', the maximum value of z at
#      which such interpolations are needed. (default: set to maximum value in
#      above 'z_pk' input)
#z_max_pk = 10.



# ----------------------------------
# ----> Lensing parameters:
# ----------------------------------

# 1) Relevant only if you ask for 'tCl, lCl' and/or 'pCl, lCl': if you want the
#    spectrum of lensed Cls. Can be anything starting with 'y' or 'n'.
#    (default: no lensed Cls)
lensing = yes


# 2) Should the lensing potential [phi+psi](k,tau) and the lensing spectrum Cl_phiphi be rescaled?
#    You can rescale [phi+psi](k,tau) at all times by an overall amplitude and tilt: lcmb_rescale*(k/lcmb_pivot)**lcmb_tilt
#    Or, more simply, you can pass the usual parameter 'A_l', and the potential will be rescaled by sqrt(A_L)
#    (matches standard definition in Calabrese et al. 0803.2309)
#    (default: no rescaling: A_L=lcmb_rescale=1)
A_L =
#lcmb_rescale = 1
#lcmb_tilt = 0
#lcmb_pivot = 0.1



# -------------------------------------
# ----> Distortions parameters:
# -------------------------------------

# 1) Which kind of appriximation would you like to use for the calculation of the
#    branching ratios?
#    To use approximation 1) 'branching approx'=sharp_sharp
#    To use approximation 2) 'branching approx'=sharp_soft
#    To use approximation 3) 'branching approx'=soft_soft
#    To use approximation 4) 'branching approx'=soft_soft_cons
#    To use approximation 5) 'branching approx'=exact
#
#    Approximation 3) violates energy conservation in the plasma, and is discouraged.
#    Please be aware, that the total energy injected will NOT include the residual distortion energy.
#    (default set to 'exact')
sd_branching_approx = exact

# 1.a) If the branching ratios are = exact, the user can specify additional parameters. For any other
#      branching ratio approximation, all of the following parameters are going to be ignored.
# 1.a.1) How many multipoles do you want to use for the residuals in the case of the PCA
#        analysis? The value can vary between 0 and 6. (default set to 2)
sd_PCA_size = 2

# 1.a.2) If PCA size is different from 0, you need to specify the chosen detector, by defining
#        setting "sd_detector_name" and defining any of 1.a.3.x).
#        In external/distortions, the file detectors_list.dat contains a list
#        of currently "known" detectors, i.e. detectors for which the PCA decomposition
#        has already been computed. If no detector name is specified, but the detector specifics
#        1.a.3.x) are, the name will be created automatically. If no name and no specifics are
#        given, PIXIE values are going to be assumed.
#
#        For instance, in the case of "sd_detector_name=PIXIE", the values are fixed respectively to 30 GHz,
#        1005 GHz, 15 GHz and 5 10^-26 W/(m^2 Hz sr), and all spectral shapes and branching ratios are
#        already precumputed.
#
#        It would be very helpful if, once computed the vectors for a new detector, the user would
#        send us the files containing spectral shapes and branching ratios (see e.g.
#        external/distortions for templates).
sd_detector_name = PIXIE

# 1.a.3) Provide the specifics of the detector (frequencies and sensitivities)
#        Either define a path to a full noise file or enter the specifics here
# 1.a.3.1) Give a path to the full noise file containing
#            - the frequency array in GHz and
#            - the detector noise in 10^-26 W/(m^2 Hz sr) for each frequency
#          Please supply the path relative to external/distortions
#sd_detector_file = FIRAS_nu_delta_I.dat

# 1.a.3.2) If you did not supply the full noise file, you need to set
#            - the minumum frequency in GHz
#            - the maximum frequency in GHz
#            - the bin width in GHz or alternatively the number of bins
#            - the detector noise in 10^-26 W/(m^2 Hz sr)
#          of the chosen detector.
#sd_detector_nu_min = 30.
#sd_detector_nu_max = 1000.
#sd_detector_nu_delta = 15.
#sd_detector_bin_number = 65
#sd_detector_delta_Ic = 5.


# 2) Only calculate non-LCDM contributions to heating?
#    Sometimes, for comparison, one might want to disable all LCDM contributions to SDs.
#    Can be set to anything starting with 'y' or 'n' (default: no)
sd_only_exotic = no


# 3) Include g distortions?
#    Can be set to anything starting with 'y' or 'n' (default: no)
sd_include_g_distortion = no


# 4) If you want to manually add a y and/or a mu parameter on top of the calculated values, specify
#    'sd_add_y' or 'sd_add_mu' or both (default set to 0 for both)
sd_add_y = 0.
sd_add_mu = 0.


# 5) Include SZ effect from reionization? Can be set to anything starting with 'y' or 'n'
#    (default: no)
include_SZ_effect = no

# 5.a) Specify the type of approximation you want to use for the SZ effect
#        - by setting 'sd_reio_type' to 'Nozawa_2005', the approximation by Nozawa et al. 2005 is employed.
#        - by setting 'sd_reio_type' to 'Chluba_2012', the approximation by Chluba et al. 2012 is employed.
#          Note that, for the moment, this appoximation is only valid for cluster temperatures lower
#          than few KeV.
#      (default set to 'Chluba_2012')
#sd_reio_type = Chluba_2012



# ----------------------------------
# ----> Output parameters:
# ----------------------------------

# 1) Output for external files
# 1.a) File name root 'root' for all output files (if Cl requested, written to
#      '<root>_cl.dat'; if P(k) requested, written to '<root>_pk.dat'; plus
#      similar files for scalars, tensors, pairs of initial conditions, etc.;
#      if file with input parameters requested, written to
#      '<root>_parameters.ini')
#      If no root is specified, the root will be set to 'output/<thisfilename>'
#      (default: output/<thisfilename>)
#root = output/test

# 1.a.1) If root is specified, do you want to keep overwriting the file,
#      or do you want to create files numbered as '<root>N_'.
#      Can be set to anything starting with 'y' or 'n' (default: no)
overwrite_root = no

# 1.b) Do you want headers at the beginning of each output file (giving
#      precisions on the output units/ format) ? Can be set to anything
#      starting with 'y' or 'n' (default: yes)
headers = yes

# 1.c) In all output files, do you want columns to be normalized and ordered
#      with the default CLASS definitions or with the CAMB definitions (often
#      idential to the CMBFAST one) ? Set 'format' to either 'class', 'CLASS',
#      'camb' or 'CAMB' (default: 'class')
format = class

# 1.d) Do you want to write a table of background quantitites in a file? This
#      will include H, densities, Omegas, various cosmological distances, sound
#      horizon, etc., as a function of conformal time, proper time, scale
#      factor. Can be set to anything starting with 'y' or 'no' (default: no)
write_background = no

# 1.e) Do you want to write a table of thermodynamics quantitites in a file?
#      Can be set to anything starting with 'y' or 'n'. (default: no)
write_thermodynamics = no

# 1.f) Do you want to write a table of perturbations to files for certain
#      wavenumbers k? Dimension of k is 1/Mpc. The actual wave numbers are
#      chosen such that they are as close as possible to the requested k-values. (default: none)
#k_output_values = 0.01, 0.1, 0.0001

# 1.g) Do you want to write the primordial scalar(/tensor) spectrum in a file,
#      with columns k [1/Mpc], P_s(k) [dimensionless], ( P_t(k)
#      [dimensionless])? Can be set to anything starting with 'y' or 'n'. (default: no)
write_primordial = no

# 1.h) Do you want to write the exotic energy injection function in a file,
#     with columns z [dimensionless], dE/dz_inj, dE/dz_dep [J/(m^3 s)]?
# 1.i) Do you want to write also the non-injected photon heating?
#     File created if 'write_exotic_injection' or
#     'write_noninjection' set to something containing the letter
#     'y' or 'Y', file written, otherwise not written (default: no)
write_exotic_injection = no
#write_noninjection = no

# 1.k) Do you want to write the spectral distortions in a file,
#     with columns x [dimensionless], DI(x) [dimensionless]?
#     File created if 'write_distortions' set to something containing the letter
#     'y' or 'Y', file written, otherwise not written (default: no)
write_distortions = no

# 1.l) Do you want to have all input/precision parameters which have been read
#      written in file '<root>parameters.ini', and those not written in file
#      '<root>unused_parameters' ? Can be set to anything starting with 'y'
#      or 'n'. (default: yes)
write_parameters = yes

# 1.m) Do you want a warning written in the standard output when an input
#      parameter or value could not be interpreted ? Can be set to anything starting
#      with 'y' or 'n' (default: no)
write_warnings = no

# 2) Amount of information sent to standard output: Increase integer values
#    to make each module more talkative (default: all set to 0)
input_verbose = 1
background_verbose = 1
thermodynamics_verbose = 1
perturbations_verbose = 1
transfer_verbose = 1
primordial_verbose = 1
harmonic_verbose = 1
fourier_verbose = 1
lensing_verbose = 1
distortions_verbose = 1
output_verbose = 1
